##########################
# code for distance btw probability matrices
##########################
library(gtools)
library(MCMCpack)
library(cmvnorm)
library(rTensor)
library(ppls)
######## Auxiliary functions to speed up ##############
# normalize a complex vector #
norm.complex = function(x) return(x/sqrt(sum(Mod(x)^2)))
# taking the diagonal faster #
Di.ag = function(A,B)return(sapply(1:nrow(A),function(s) A[s,]%*%B[,s]))
# return the eigen vectors
eigen.vec = function(A) return(eigen(A)$vectors)
# return the projectors
projectors = function(a,r){
tem1 = lapply(basis[a],eigen.vec)
tem3 = lapply(1:length(tem1), function(s) return(tem1[[s]][r[s],]))
lapply(tem3, function(x) x%*%Conj(t(x)))
}
#Pauli basis 2x2
sx = matrix(c(0,1,1,0),nr=2)
sy = matrix(c(0,1i,-1i,0),nr=2)
sz = matrix(c(1,0,0,-1),nr=2)
basis = list(diag(2),sx,sy,sz)
## #qubits
n = 4
## total number of a, b and r
b = permutations(4,n,  repeats.allowed=T)
a = permutations(3,n, v=c(2,3,4), repeats.allowed=T)
r = permutations(2,n, v = c(1,2),  repeats.allowed=T)
### Pauli basis for n qubit
sig_b = list()
for (i in 1:n^4){
sig_b[[i]] = kronecker_list(basis[b[i,]])
}
### matrix P_{(r,a);b}
J = 4^n
I = 6^n
d = R = 2^n
A = 3^n
P_rab = matrix(0,nc =J, nr= I)
for(j in 1:J){
temp = matrix(0,nr=R,nc=A)
for(s in 1:R){
for(l in 1:A){
temp[s,l] = prod(r[s, b[j,]!=1])*prod(a[l,b[j,]!=1]==b[j,b[j,]!=1])
}
}
P_rab[,j] = c(temp)
}
load("C:/Users/tmai/Dropbox/New works Tien/data/W4-Data.dat")
load("~/AppData/Dropbox/bin/Dropbox.exe")
load("~/AppData/Dropbox/bin/Dropbox.exe")
setwd("C:/Users/tmai/Dropbox/New works Tien/data")
W4.Data <- read.delim("C:/Users/tmai/Dropbox/New works Tien/data/W4-Data.dat", header=FALSE)
View(W4.Data)
W4.Data <- as.matrix(W4.Data)
W4.Data <- W4.Data[,-1]
p_ra = c(t(W4.Data))
temp1 = p_ra%*%P_rab
temp1 = temp1/16
rho_b = c()
for(i in 1:4^n){
rho_b[i] = temp1[i]/3^(sum(b[i,]==1))
}
rho.hat = matrix(0,nr=2^n,nc=2^n)
for(s in 1:4^n){
rho.hat = rho.hat + rho_b[s]*sig_b[[s]]
}
lamb.hat = eigen(rho.hat)$value
u.hat = eigen(rho.hat)$vectors
Lamb = rdirichlet(1, rep(.1,2^n))
S <- emulator::cprod(rcmvnorm(d,mean=rep(0,d),sigma=diag(d)))
U <- sapply(1:2^n,function(i) norm.complex(rcmvnorm(1,sigma=S)))
sqrt(sum((Lamb - lamb.hat)^2))
sort(lamb.hat)
sort(lamb.hat,T)
max(lamb.hat,0)
proj.simplex = function(x){
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(u[i] +(1-sum(u))/i>0)
return u[i] +(1-sum(u))/i))
tem2 = (1-sum(u[1:tem1]))/tem1
return(tem2)
}
proj.simplex = function(x){
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(u[i] +(1-sum(u))/i)0)
return u[i] +(1-sum(u))/i))
tem2 = (1-sum(u[1:tem1]))/tem1
return(tem2)
}
proj.simplex = function(x){
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(u[i] +(1-sum(u))/i)>0)
return u[i] +(1-sum(u))/i))
tem2 = (1-sum(u[1:tem1]))/tem1
return(tem2)
}
proj.simplex = function(x){
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(((1-sum(u))/i +u[i]) >0)
return u[i] +(1-sum(u))/i))
tem2 = (1-sum(u[1:tem1]))/tem1
return(tem2)
}
proj.simplex = function(x){
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i))
tem2 = (1-sum(u[1:tem1]))/tem1
return(tem2)
}
proj.simplex = function(x){
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i)))
tem2 = (1-sum(u[1:tem1]))/tem1
return(tem2)
}
proj.simplex(lamb.hat)
proj.simplex(unlist(lamb.hat))
unlist(lamb.hat)
x = unlist(lamb.hat)
str(x)
u = sort(x,T)
tem1 = max(sapply(1:length(x),
function(i) if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i)))
tem1 = max(sapply(1:length(x),
function(i){ if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i)}))
sapply(1:length(x),
function(i){ if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i)})
tem1 = max(unlist(sapply(1:length(x),
function(i){ if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i)})))
tem1
(1-sum(u))/i +u[i]
i
i=1
(1-sum(u))/i +u[i]
sum(u)
tem1 = which.max(unlist(sapply(1:length(x),
function(i){ if(((1-sum(u))/i +u[i]) >0)
return (u[i] +(1-sum(u))/i)})))
tem1
tem2 = (1-sum(u[1:tem1]))/tem1
(1-sum(u[1:tem1]))/tem1
lamb.hat + tem2
lamb.hat
lamb.hat = eigen(rho.hat)$value
u.hat = eigen(rho.hat)$vectors
u.hat
str(u,hat)
eigen(rho.hat)$vectors
u.hat[1]
u.hat[,1]
sqrt(sum(Mod(u.hat)^2))
sqrt(sum(Mod(u.hat[,1])^2))
sqrt(sum(Mod(u.hat[1,])^2))
sqrt(sum(Mod(u.hat[3,])^2))
sqrt(sum(Mod(u.hat[,3])^2))
